{
  "metadata": {
    "type": "always_apply",
    "description": "Core rules: per-step workflow pattern, evidence-before-assertion, OCR verification, use existing browser windows, ask don't guess",
    "version": "4.0"
  },
  "total_rules": 7,
  "rules": [
    {
      "rule_number": 0,
      "title": "Rule 0: Per-Step Workflow Pattern (META-RULE)",
      "content": "**PER STEP (not per task):**\n\n1. State which rules apply to THIS step\n2. Execute THIS step\n3. Show full evidence (terminal output, OCR)\n4. Verify compliance\n\n**Forbidden:** Bulk execution, no evidence, claims without OCR, showing file size instead of screenshot to user.\n\n**Pattern:**\n```\n### Step N: [description]\n**Rules:** Rule X, Rule Y\n**Command:** [exact command]\n**Evidence:** [full output]\n**Compliance:** ‚úÖ Rule X satisfied because...\n```"
    },
    {
      "rule_number": 1,
      "title": "Rule 1: Workspace Authority (HARD STOP)",
      "content": "Before any code, test, build, or deployment discussion, the assistant must declare:\n\nRepository name\n\nAbsolute or repo-relative root path\n\nAll actions apply only to that workspace.\nIf unclear ‚Üí stop and ask.\n\n2. Evidence Before Assertion (HARD STOP)\n\nThe assistant may not claim success of builds, tests, deployments, UI behavior, or APIs without raw evidence.\n\nValid evidence:\n\nFull terminal output\n\ncurl / grep output\n\nBrowser console logs\n\nSelenium logs\n\nScreenshots (when relevant)\n\nRequired format:\n\nEvidence:\n<raw output>\n\nConclusion:\n<derived only from evidence>\n\n3. Execution Boundary (CRITICAL)\n\nThe assistant must never imply it executed actions.\n\nForbidden: ‚ÄúI ran‚Äù, ‚ÄúI deployed‚Äù, ‚ÄúI tested‚Äù, ‚ÄúI verified‚Äù.\n\nAllowed:\n\n‚ÄúThe output shows‚Ä¶‚Äù\n\n‚ÄúBased on the provided logs‚Ä¶‚Äù\n\n4. Stop-the-Line Conditions (HARD STOP)\n\nImmediately stop if any occur:\n\nConflicting tool outputs\n\nWorkspace ambiguity\n\nUnverified deployment or test claims\n\nExplicit user correction\n\nActive user constraints violated\n\nOnly clarification is allowed until resolved.\n\n5. Ask, Don‚Äôt Guess (HARD STOP)\n\nIf intent, path, tooling, or solution choice is ambiguous:\n\nDo not proceed\n\nDo not assume\n\nRequired format:\n\nCLARIFICATION NEEDED:\n- Situation:\n- Options:\n- Question:\n\n6. Scope Containment\n\n‚ÄúFix everything related‚Äù means:\n\nFix all instances of the current defect class\n\nDo not add features, refactor, or expand scope unless asked\n\nIf a related issue is found, ask before acting.\n\n7. Observation Layer Integrity\n\nAll statements must be tagged as:\n\nFilesystem\n\nBuild-time\n\nRuntime (browser/API)\n\nDeployment (remote)\n\nCross-layer conclusions without evidence are prohibited.\n\n8. Feature Preservation (CRITICAL)\n\nIf the user says ‚Äúdo not remove features‚Äù:\n\nRequired workflow:\n\nEnumerate existing features\n\nMake changes\n\nVerify each feature still works\n\nProvide evidence per feature\n\nNo silent removals. No assumptions.\n\n9. End-to-End Workflow Proof & Selenium Testing (CRITICAL)\n\nLoading a page ‚â† proof.\n\nWhen testing or documenting functionality, the assistant must demonstrate the complete user workflow, including:\n\nSetup\n\nUsage\n\nData persistence\n\nIntegration points\n\nFailure paths (where applicable)\n\n### Selenium Testing Requirements (MANDATORY)\n\n**CRITICAL: Selenium tests MUST run in VISIBLE mode (NOT headless) unless explicitly specified otherwise by the user.**\n\nForbidden:\n- `options.add_argument('--headless')`\n- `options.headless = True`\n- Any headless configuration\n\nAllowed only if user explicitly requests:\n- \"run selenium in headless mode\"\n- \"use headless browser\"\n\nRationale: Visible mode allows user to see what's happening, verify behavior visually, and debug issues. Headless mode hides problems and prevents user observation.\n\n### Screenshot Requirements (MANDATORY)\n\n**All screenshots MUST:**\n1. **Be taken at EACH major step** of the workflow (not just initial page load)\n2. **Be saved with descriptive filenames** (e.g., `screenshot_01_frontend_loaded.png`, `screenshot_02_backend_status.png`)\n3. **Be verified with OCR** (Tesseract or similar) to confirm text is visible\n4. **Be embedded in documentation** (README.md, evidence documents) with:\n   - Image markdown: `![Description](./screenshot_name.png)`\n   - Caption describing what the screenshot shows\n   - OCR verification note if applicable\n5. **Show actual UI state** (not blank pages, loading screens, or error states unless testing errors)\n6. **Include console logs** captured via Chrome DevTools Protocol\n7. **Be taken in VISIBLE mode** (user can see browser window during test)\n\n### MANDATORY: Test Script with Evidence (HARD STOP)\n\n**Before claiming any feature is complete, the assistant MUST**:\n\n- [ ] Create test script (`test_*.py`) that runs in VISIBLE mode\n- [ ] Take screenshots at EVERY step (minimum 10 for complete workflow)\n- [ ] Use OCR to verify EVERY screenshot\n- [ ] **Display OCR output in terminal** (proof it was read)\n- [ ] Test COMPLETE workflow (not just page load)\n- [ ] Capture browser console logs\n- [ ] Show console log summary (total, errors, warnings)\n- [ ] Embed screenshots in README.md or evidence document\n- [ ] **Show terminal output proving all above steps were done**\n\n**If ANY item is unchecked, the feature is NOT complete.**\n\n**Example terminal output REQUIRED**:\n```\nSTEP 1: Load page and verify UI\nüì∏ Screenshot saved: screenshots/01_page_loaded.png\n   File size: 1,234,567 bytes\n\nüîç OCR Verification:\n   Extracted text (first 500 chars):\n   ----------------------------------------------------------------------------\n   Marketplace Bulk Editor\n   Upload Excel File\n   Backend Status: Connected\n   ----------------------------------------------------------------------------\n\n‚úÖ Verification for Step 1:\n   ‚úÖ Found: 'Marketplace Bulk Editor'\n   ‚úÖ Found: 'Upload'\n   ‚úÖ Found: 'Backend'\n\nüìã Browser Console Logs (Step 1):\n   Total entries: 5\n   Errors: 0\n   Warnings: 0\n```\n\n**This terminal output is PROOF that**:\n- Screenshot was actually taken (not just claimed)\n- OCR was actually run (not just claimed)\n- Text was actually verified (not just claimed)\n- Console logs were actually captured (not just claimed)\n- Feature actually works (not just claimed)\n\n**Without this evidence, claims of \"it works\" are not credible.**\n\n**Why this matters**: See `WHY_SCREENSHOTS_MATTER.md` for full explanation of why the user repeatedly asks for screenshots and OCR verification.\n\n### Complete Workflow Testing (Rule 22)\n\n**The assistant MUST test the COMPLETE workflow, not just initial page load.**\n\n**For backend/database features, minimum steps:**\n1. Setup: `./docker-start.sh` + container status\n2. User registration: API call + JWT tokens\n3. Login: API call + response\n4. Create listing: API call + database verification\n5. Templates: Creation + usage\n6. OCR: File upload + processing + results\n7. Export: Export + file content verification\n8. Rate limiting: 429 error after exceeding limits\n9. Database: `psql` queries proving persistence\n10. Redis: `redis-cli` commands proving caching\n11. Cleanup: `./docker-stop.sh` + data preservation\n\n**For UI features, minimum steps:**\n1. Initial load\n2. Backend status (collapsed + expanded)\n3. File upload area\n4. Data table with data\n5. Cell editing (before/after)\n6. Export preview modal\n7. Dark mode toggle\n8. Search/filter\n9. Bulk actions\n10. Undo/redo\n\n**Minimum screenshots required:**\n- Backend/database features: 13+ screenshots\n- UI features: 10+ screenshots\n\n### Console Log Capture (MANDATORY)\n\n**All Selenium tests MUST capture console logs:**\n\n```python\nfrom selenium.webdriver.chrome.options import Options\n\noptions = Options()\noptions.set_capability('goog:loggingPrefs', {'browser': 'ALL'})\n# DO NOT add --headless unless user explicitly requests it\n\ndriver = webdriver.Chrome(options=options)\ndriver.get(\"http://localhost:5173\")\n\n# Capture console logs\nfor entry in driver.get_log('browser'):\n    print(f\"[{entry['level']}] {entry['message']}\")\n```\n\n**Report:**\n- Total console entries\n- Number of errors (should be 0 for successful tests)\n- Number of warnings\n- Sample of info/debug messages\n\n### OCR Verification (MANDATORY)\n\n**All screenshots MUST be verified with OCR:**\n\n```python\nimport pytesseract\nfrom PIL import Image\n\nimg = Image.open('screenshot_01_frontend_loaded.png')\ntext = pytesseract.image_to_string(img)\n\n# Verify expected text appears\nassert \"Docker Backend Connected\" in text\nassert \"Marketplace Bulk Editor\" in text\n```\n\n**Report:**\n- Screenshot filename\n- File size\n- OCR extracted text (key phrases)\n- Verification status (‚úÖ or ‚ùå)\n\n### Documentation Requirements (MANDATORY)\n\n**After Selenium testing, the assistant MUST:**\n\n1. **Embed screenshots in README.md** with:\n   - Section titled \"üì∏ Screenshots (Selenium Testing - VISIBLE Mode)\"\n   - Each screenshot with descriptive caption\n   - OCR verification note\n   - Console logs status (0 errors)\n   - Test date\n\n2. **Create evidence document** (e.g., COMPLETE_WORKFLOW_EVIDENCE.md) with:\n   - Executive summary of all tested features\n   - Step-by-step workflow with terminal output\n   - API request/response examples\n   - Database query results\n   - Screenshot references with OCR results\n   - Compliance checklist\n\n3. **Update backend/README.md** (if applicable) with:\n   - Complete API workflow examples\n   - Database verification examples\n   - Redis verification examples\n   - Rate limiting demonstration\n\n### Failure to Comply\n\n**If the assistant:**\n- Uses headless mode without explicit user request\n- Takes only 1-2 screenshots instead of complete workflow\n- Does not verify screenshots with OCR\n- Does not embed screenshots in README.md\n- Does not capture console logs\n- Does not test complete workflow\n\n**Then the user MUST stop the assistant and request compliance with Rule 9.**\n\n10. User Constraints Override Everything\n\nExplicit user constraints override:\n\nDefaults\n\nPrior behavior\n\n‚ÄúBest practices‚Äù\n\nConstraints persist until revoked.\n\nRequired acknowledgment:\n\nActive constraints:\n1. ‚Ä¶\n2. ‚Ä¶\n\nKnown Critical Failure Classes (Do Not Regress)\n\nThese are non-negotiable checks when applicable:\n\nORM Safety\n\nNever use reserved names (metadata, query, session, registry)\n\nTest DB initialization immediately\n\nDocker Configuration\n\nAll required env vars must be passed (DB, cache, rate limits, secrets)\n\nVerify connectivity before claiming success\n\nPython Versions\n\nUse stable Python (3.11 / 3.12) in Docker\n\nDo not use bleeding-edge images\n\nDatabase Alignment\n\nDo not change database type without user approval\n\nPreserve SQL export paths if present\n\nTone After Errors\n\nAfter corrections or failures:\n\nNeutral\n\nTechnical\n\nFactual\n\nNo celebratory language."
    },
    {
      "rule_number": 23,
      "title": "Rule 23: Use Existing Browser Windows (CRITICAL) [DEPRECATED - See Rule 24]",
      "content": "When the user says:\n- \"use xdotool to find the open firefox window\"\n- \"test the button in the open firefox window\"\n- \"press save in the open firefox window\"\n- \"the error persists\" (implies they already tested)\n\n**The assistant MUST:**\n1. **NOT create a new browser instance**\n2. **NOT write a new test script**\n3. **Use xdotool to interact with the EXISTING window**\n4. **Assume the user has already done setup** (login, data upload, etc.)\n\n**Forbidden Actions:**\n- Creating new Selenium WebDriver instances\n- Writing test scripts that start from scratch\n- Ignoring \"the open firefox window\" instruction\n- Assuming the user hasn't tested yet\n\n**Required Actions:**\n1. Use `xdotool search --name \"Firefox\"` to find window ID\n2. Use `xdotool windowactivate <ID>` to focus the window\n3. Use `xdotool` commands to interact with the existing window\n4. OR ask the user what they see in the browser\n\n**Why This Rule Exists:**\n- User has already spent time setting up the browser state\n- Creating new instances wastes user's time\n- User explicitly requested using the existing window\n- \"The error persists\" means user already tested and saw failure\n\n---"
    },
    {
      "rule_number": 24,
      "title": "Rule 24: Test Before Push (HARD STOP)",
      "content": "**NEVER push broken code.**\n\n**Before ANY git push, the assistant MUST**:\n\n1. ‚úÖ Run dev server (`npm run dev`)\n2. ‚úÖ Run Selenium test in VISIBLE mode\n3. ‚úÖ Verify 0 critical errors in console logs\n4. ‚úÖ Verify OCR finds expected text\n5. ‚úÖ Show terminal output proving app works\n\n**If ANY item fails, FIX THE CODE before pushing.**\n\n**Example of VIOLATION**:\n```\nLLM: \"I'll push the code now.\"\nUser: \"Did you test it?\"\nLLM: \"The test showed errors but I pushed anyway.\"\nUser: \"That's broken code! Don't push broken code!\"\n```\n\n**Correct workflow**:\n```\n1. Make changes\n2. Run dev server\n3. Run Selenium test\n4. See errors in test output\n5. FIX THE ERRORS\n6. Run test again\n7. Verify 0 errors\n8. THEN push\n```\n\n**Why this matters**:\n- Pushing broken code breaks production\n- Users can't use broken code\n- Wastes time fixing later\n- Violates basic development practices\n\n**This is non-negotiable.**\n\n---"
    },
    {
      "rule_number": 25,
      "title": "Rule 25: Display Debug Info in UI, Not Console (CRITICAL)",
      "content": "**When the user says:**\n- \"save it yourself in the debug area at the bottom of the page\"\n- \"having the user (me) get it increases chance of error\"\n- \"why not display it in the UI?\"\n\n**The assistant MUST:**\n1. **Add debug state to the relevant Context** (e.g., DataContext, AuthContext)\n2. **Create or use existing debug panel component** in the UI\n3. **Display all debug information automatically** without requiring user to open browser console\n4. **Show timestamps, log levels (info/warn/error/success), and data**\n\n**Forbidden Actions:**\n- Only logging to console.log without UI display\n- Requiring user to manually copy/paste console output\n- Creating debug logs that aren't visible in the UI\n- Ignoring existing debug panels\n\n**Why This Rule Exists:**\n- User shouldn't have to open browser console (F12)\n- Manual copy/paste increases chance of error\n- Debug info should be automatically captured and displayed\n- Following this instruction made short work of the \"Failed to save to database\" issue\n\n**Example Implementation:**\n```typescript\n// Context\nconst [debugLogs, setDebugLogs] = useState<DebugLog[]>([]);\nconst addDebugLog = (level, message, data) => {\n  setDebugLogs(prev => [...prev, { timestamp: new Date().toISOString(), level, message, data }]);\n  console.log(`${emoji} [${message}]`, data); // Also log to console\n};\n\n// UI Component\n{debugLogs.map((log, idx) => (\n  <div key={idx} className={getColorClass(log.level)}>\n    [{new Date(log.timestamp).toLocaleTimeString()}] {getEmoji(log.level)} {log.message}\n    {log.data && <pre>{JSON.stringify(log.data, null, 2)}</pre>}\n  </div>\n))}\n```\n\n**Real-World Success:**\n- User reported \"Failed to save to database\" error\n- Assistant added debug logging to DataContext\n- Debug panel showed: \"‚ö†Ô∏è Skipping invalid listing 1\" with data showing undefined values\n- Root cause identified immediately: empty row with undefined title/price/condition\n- Issue resolved by filtering invalid listings before sending to backend\n\n**Example Violation:**\n```python\n# WRONG - Creates new browser\ndriver = webdriver.Firefox(options=options)\ndriver.get(\"http://localhost:5173\")\n```\n\n**Correct Approach:**\n```bash\n# RIGHT - Use existing window\nxdotool search --name \"Firefox\" windowactivate\n# Then ask user what they see or use xdotool to click\n```\n\n**If the assistant violates this rule:**\n- User will have to repeat the instruction\n- User's time is wasted\n- User's frustration increases\n- Assistant demonstrates it's not listening\n\n---"
    },
    {
      "rule_number": 26,
      "title": "Rule 26: Use Existing Browser Window with xdotool (CRITICAL)",
      "content": "**When the user says:**\n- \"the page is open in firefox\"\n- \"page is open in firefox, do not waste time using chrome\"\n- \"Import more fails\" (implies they already tried it)\n- \"the button doesn't work\" (implies they already clicked it)\n- Any statement indicating they have the app already open\n\n**The assistant MUST:**\n1. **Find the CORRECT Firefox window** (see workflow below)\n2. **Activate that specific window** using its window ID\n3. **Use source code to determine button location** (don't guess)\n4. **Use OCR to find exact coordinates** of UI elements\n5. **Click buttons using xdotool** to trigger actions\n6. **Read errors from Debug Console** (already visible in UI per Rule 25)\n\n**The assistant MUST NOT:**\n- Create new Selenium WebDriver instances\n- Write new test scripts that start from scratch\n- Ask user to manually click buttons\n- Ask user to copy/paste console output (Debug Console already shows it)\n- Ignore that the user has already set up the browser state\n- Use `xdotool search --name \"Firefox\" windowactivate` without finding the CORRECT window first\n\n**Why This Rule Exists:**\n- User has already spent time setting up browser state (login, data upload, etc.)\n- Creating new browser instances wastes user's time\n- User explicitly stated which browser they're using\n- Debug Console already shows all errors (Rule 25)\n- Source code tells us exactly where buttons are located\n- OCR can find exact pixel coordinates\n- **Multiple Firefox windows may be open - must find the RIGHT one**\n\n**MANDATORY WORKFLOW - Find Correct Firefox Window:**\n\n```bash\n# Step 1: List ALL Firefox windows with their titles\nDISPLAY=:0 xdotool search --name \"Firefox\" 2>&1 | while read wid; do\n  echo \"Window $wid: $(DISPLAY=:0 xdotool getwindowname $wid 2>&1)\"\ndone\n\n# Output example:\n# Window 60817409: Firefox\n# Window 60838438: Firefox\n# Window 60842863: marketplace-bulk-editor ‚Äî Mozilla Firefox Private Browsing\n\n# Step 2: Find the window ID that contains \"marketplace\" or the app name\n# In this example: 60842863\n\n# Step 3: Activate THAT SPECIFIC window\nDISPLAY=:0 xdotool windowactivate 60842863\n\n# Step 4: Wait for window to come into focus\nsleep 1\n\n# Step 5: Verify window is active by taking screenshot\nDISPLAY=:0 import -window root /tmp/firefox_active.png\n\n# Step 6: Use OCR to verify correct window is showing\npython3 << 'EOF'\nimport pytesseract\nfrom PIL import Image\nimg = Image.open('/tmp/firefox_active.png')\ntext = pytesseract.image_to_string(img)\nif 'Marketplace Bulk Editor' in text:\n    print(\"‚úÖ Correct Firefox window is active\")\nelse:\n    print(\"‚ùå Wrong window - marketplace app not visible\")\n    print(text[:500])\nEOF\n```\n\n**MANDATORY WORKFLOW - Click Button in Active Window:**\n\n```bash\n# Step 1: Firefox window is already active (from above)\n\n# Step 2: Use OCR to find button coordinates\npython3 << 'EOF'\nimport pytesseract\nfrom PIL import Image\nimg = Image.open('/tmp/firefox_active.png')\ndata = pytesseract.image_to_data(img, output_type=pytesseract.Output.DICT)\nfor i, text in enumerate(data['text']):\n    if 'Import More' in text or 'Import' in text:\n        x = data['left'][i] + data['width'][i]//2\n        y = data['top'][i] + data['height'][i]//2\n        print(f\"Found '{text}' at ({x}, {y})\")\nEOF\n\n# Step 3: Click the button at those coordinates\nDISPLAY=:0 xdotool mousemove <x> <y> click 1\n\n# Step 4: Wait for action to complete\nsleep 2\n\n# Step 5: Take screenshot of result\nDISPLAY=:0 import -window root /tmp/after_click.png\n\n# Step 6: Use OCR to read Debug Console for errors\npython3 << 'EOF'\nimport pytesseract\nfrom PIL import Image\nimg = Image.open('/tmp/after_click.png')\ntext = pytesseract.image_to_string(img)\nprint(\"=== SCREEN AFTER CLICK ===\")\nprint(text)\nEOF\n```\n\n**How to Find Button Location from Source Code:**\n\n1. Search codebase for button text (e.g., \"Import More\")\n2. Find the component that renders it\n3. Understand the layout structure\n4. Use OCR to locate it on screen\n5. Click using xdotool\n\n**Example:**\n```typescript\n// Source code shows:\n<button className=\"...\">\n  <Upload size={16} />\n  Import More\n</button>\n\n// This tells us:\n// - Button contains text \"Import More\"\n// - Button has Upload icon\n// - Use OCR to find \"Import More\" text\n// - Click at those coordinates\n```\n\n**Common Mistakes (FORBIDDEN):**\n\n‚ùå **WRONG - Activates random Firefox window:**\n```bash\nDISPLAY=:0 xdotool search --name \"Firefox\" windowactivate\n# This activates the FIRST window found, not the correct one!\n```\n\n‚ùå **WRONG - Doesn't verify which window is active:**\n```bash\nDISPLAY=:0 xdotool windowactivate 12345\n# Takes screenshot but doesn't check if marketplace app is visible\n```\n\n‚ùå **WRONG - Takes screenshot but window isn't in focus:**\n```bash\nDISPLAY=:0 import -window root /tmp/screenshot.png\n# Screenshot shows IDE/terminal instead of Firefox\n# User complains: \"I am not seeing the target Firefox window come into focus\"\n```\n\n‚úÖ **CORRECT - Find specific window, activate it, verify it:**\n```bash\n# 1. List all windows\nDISPLAY=:0 xdotool search --name \"Firefox\" | while read wid; do\n  echo \"$wid: $(DISPLAY=:0 xdotool getwindowname $wid)\"\ndone\n\n# 2. Find the one with \"marketplace\" in title\n# Output: 60842863: marketplace-bulk-editor ‚Äî Mozilla Firefox\n\n# 3. Activate THAT window\nDISPLAY=:0 xdotool windowactivate 60842863\n\n# 4. Wait and verify\nsleep 1\nDISPLAY=:0 import -window root /tmp/verify.png\npython3 -c \"import pytesseract; from PIL import Image; print('Marketplace' in pytesseract.image_to_string(Image.open('/tmp/verify.png')))\"\n# Output: True (verified!)\n```\n\n**What's Missing from Previous Rules:**\n\n**Rule 23** said \"use existing browser\" but was marked DEPRECATED and didn't explain HOW to use xdotool effectively.\n\n**The gap was:**\n- ‚ùå No instruction to LIST all Firefox windows first\n- ‚ùå No instruction to FIND the correct window by title\n- ‚ùå No instruction to ACTIVATE the specific window ID\n- ‚ùå No instruction to VERIFY the window is in focus\n- ‚ùå No instruction to use source code to find button locations\n- ‚ùå No instruction to use OCR for exact coordinates\n- ‚ùå No instruction to click buttons with xdotool\n- ‚ùå No instruction to read Debug Console for errors (instead of asking user)\n\n**This rule fills that gap by requiring:**\n1. ‚úÖ List ALL Firefox windows with titles\n2. ‚úÖ Find the window ID containing the app name\n3. ‚úÖ Activate THAT SPECIFIC window by ID\n4. ‚úÖ Verify window is in focus with OCR\n5. ‚úÖ Use source code to understand UI structure\n6. ‚úÖ Use OCR to find exact pixel coordinates\n7. ‚úÖ Use xdotool to click buttons\n8. ‚úÖ Read Debug Console automatically (don't ask user)\n9. ‚úÖ Take screenshots before/after to verify actions\n\n**Failure to Comply:**\n\nIf the assistant:\n- Uses `xdotool search --name \"Firefox\" windowactivate` without finding correct window first\n- Doesn't list all Firefox windows to find the right one\n- Doesn't verify the window is in focus before clicking\n- Takes screenshots that show IDE/terminal instead of Firefox\n- Creates new Selenium instance when user said \"page is open\"\n- Asks user to click buttons manually\n- Asks user to copy/paste console output\n- Ignores user's browser choice (Firefox vs Chrome)\n- Doesn't use source code to find button locations\n\n**Then the user MUST stop the assistant and cite Rule 26.**\n\n**User Complaint That Triggered This Rule:**\n> \"again I am not seeing the target Firefox window come into focus - why?\"\n\n**Root Cause:**\n- Assistant used `xdotool search --name \"Firefox\" windowactivate` which activates the FIRST window found\n- Multiple Firefox windows were open (7 windows)\n- The correct window (ID 60842863 with \"marketplace-bulk-editor\" in title) was NOT the first one\n- Screenshots showed IDE/terminal instead of Firefox\n- Assistant didn't verify which window was active\n\n**Solution:**\n- ALWAYS list all windows first\n- ALWAYS find the correct window by title\n- ALWAYS activate by specific window ID\n- ALWAYS verify with OCR that correct window is showing\n\n---"
    },
    {
      "rule_number": 27,
      "title": "Rule 27: Screenshot Claims Require OCR Evidence (CRITICAL)",
      "content": "**Source**: Analysis of repeated mistakes in `Marketplace_Editor_Backend_Security_Upgrade_Plan__2025-12-21T12-18-12.json`\n\n### The Problem\n\n**User repeatedly had to correct the assistant:**\n- \"the false claim that the table header is not overlapping the data is incorrect\"\n- \"don't pretend you cannot see the screen, do ocr or read\"\n- \"contrary to your assertions, the problem does not persist\"\n\n**Root cause**: Assistant was GUESSING what screenshots showed instead of using OCR to READ them.\n\n### The Rule\n\n**NEVER make claims about what a screenshot shows without:**\n\n1. ‚úÖ Running OCR on the screenshot\n2. ‚úÖ Showing FULL OCR output in terminal\n3. ‚úÖ Displaying screenshot to user in VSCode (`code /tmp/screenshot.png`)\n4. ‚úÖ Basing claims ONLY on OCR text, not guesses\n\n### Forbidden Phrases (Without OCR Evidence)\n\n**These phrases are FORBIDDEN without showing OCR output first:**\n\n- ‚ùå \"I can see...\"\n- ‚ùå \"The screenshot shows...\"\n- ‚ùå \"Looking at the screenshot...\"\n- ‚ùå \"The fix appears to be working...\"\n- ‚ùå \"The problem is fixed...\"\n- ‚ùå \"The header is NOT overlapping...\"\n- ‚ùå \"The table is properly positioned...\"\n\n### Required Pattern\n\n**When verifying ANYTHING with a screenshot:**\n\n```bash\n### Step N: Verify [what you're checking] with screenshot\n\n**Rules that apply:**\n- Rule 27: Screenshot Claims Require OCR Evidence\n- Rule 2: Evidence-Before-Assertion\n- Rule 26: Use Existing Browser Window\n\n**Command:**\n# Take screenshot\nDISPLAY=:0 import -window root /tmp/verify.png\n\n# Run OCR to READ the screenshot\npython3 << 'EOF'\nimport pytesseract\nfrom PIL import Image\nimg = Image.open('/tmp/verify.png')\ntext = pytesseract.image_to_string(img)\nprint(\"=== FULL OCR OUTPUT ===\")\nprint(text)\nEOF\n\n# Show screenshot to user in VSCode\ncode /tmp/verify.png\n\n**Executing:**\n[run commands]\n\n**Evidence:**\n=== FULL OCR OUTPUT ===\n[paste FULL OCR output - do NOT summarize]\n\n**Based on OCR evidence (NOT guesses):**\n- Found text: \"TITLE | PRICE | CONDITION\"\n- Found text: \"Canadian Solar 370-395W\"\n- Overlap status: [YES/NO based on what OCR actually shows]\n- Fix status: [WORKING/NOT WORKING based on OCR evidence]\n\n**Rule compliance:**\n- Rule 27 compliance: ‚úÖ Ran OCR, showed full output, displayed screenshot to user\n- Rule 2 compliance: ‚úÖ Claims based on OCR evidence, not guesses\n```\n\n### Why This Rule Exists\n\n**From the chat log, the assistant made these mistakes repeatedly:**\n\n1. **Claimed \"no overlap\" when overlap existed**\n   - User: \"the false claim that the table header is not overlapping the data is incorrect\"\n   - Assistant had NOT run OCR, just guessed based on code changes\n\n2. **Claimed to \"see\" things without OCR**\n   - User: \"don't pretend you cannot see the screen, do ocr or read\"\n   - Assistant was describing what it THOUGHT should be there\n\n3. **Multiple incorrect diagnoses**\n   - Attempt 1: \"sticky positioning\"\n   - Attempt 2: \"z-index\"\n   - Attempt 3: \"table structure\"\n   - Attempt 4: \"main table's sticky header\"\n   - User: \"contrary to your assertions, the problem does not persist\"\n   - Assistant didn't verify EACH fix with screenshot + OCR\n\n4. **Claimed success without evidence**\n   - Assistant: \"The fix appears to be working\"\n   - User: \"the false claim... is incorrect\"\n   - No screenshot taken, no OCR run, no evidence shown\n\n### Correct vs Incorrect Examples\n\n**‚ùå INCORRECT (Violates Rule 27):**\n```\nI can see in screenshot_firefox_now.png that the table header is not overlapping\nthe data rows anymore. The fix appears to be working.\n```\n\n**Why this is wrong:**\n- No OCR output shown\n- No screenshot displayed to user\n- Claims based on guesses, not evidence\n\n**‚úÖ CORRECT (Follows Rule 27):**\n```\n### Step 3: Verify fix with screenshot\n\n**Command:**\nDISPLAY=:0 import -window root /tmp/verify.png\npython3 << 'EOF'\nimport pytesseract\nfrom PIL import Image\nimg = Image.open('/tmp/verify.png')\ntext = pytesseract.image_to_string(img)\nprint(text)\nEOF\ncode /tmp/verify.png\n\n**Evidence:**\n=== OCR OUTPUT ===\nTITLE | PRICE | CONDITION\nCanadian Solar 370-395W | $150.00 | New\n[... full OCR output ...]\n\n**Based on OCR evidence:**\n- Header text found: \"TITLE | PRICE | CONDITION\"\n- First data row found: \"Canadian Solar 370-395W | $150.00 | New\"\n- No overlap detected (data row is clearly visible below header)\n- Fix status: WORKING ‚úÖ\n```\n\n### Failure to Comply\n\n**If the assistant:**\n- Makes claims about screenshots without OCR\n- Says \"I can see\" without showing OCR output\n- Doesn't display screenshot to user with `code`\n- Guesses what screenshot shows instead of reading it\n\n**Then the user MUST stop the assistant and cite Rule 27.**\n\n---"
    }
  ]
}